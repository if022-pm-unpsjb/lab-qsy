defmodule Libremarket.AMQP.Consumer do
  @moduledoc """
  Consume mensajes de RabbitMQ y coordina la comunicación entre servicios
  """
  use GenServer
  require Logger
  alias Libremarket.AMQP.Connection

  @exchange "libremarket_exchange"
  @queue "libremarket_queue"

  def start_link(opts \\ []) do
    GenServer.start_link(__MODULE__, opts, name: __MODULE__)
  end

  @impl true
  def init(_opts) do
    send(self(), :setup)
    {:ok, %{}}
  end

  @impl true
  def handle_info(:setup, state) do
    with {:ok, channel} <- Connection.get_channel(),
         :ok <- setup_exchanges_and_queues(channel),
         {:ok, _consumer_tag} <- AMQP.Basic.consume(channel, @queue) do
      Logger.info("Consumer iniciado en cola: #{@queue}")
      {:noreply, Map.put(state, :channel, channel)}
    else
      error ->
        Logger.error("Error configurando consumer: #{inspect(error)}")
        Process.send_after(self(), :setup, 5000)
        {:noreply, state}
    end
  end

  @impl true
  def handle_info({:basic_deliver, payload, meta}, state) do
    Logger.info("Mensaje recibido: #{inspect(meta.routing_key)}")

    spawn(fn ->
      handle_message(payload, meta)
    end)

    {:noreply, state}
  end

  @impl true
  def handle_info({:basic_consume_ok, _meta}, state) do
    {:noreply, state}
  end

  @impl true
  def handle_info({:basic_cancel, _meta}, state) do
    {:stop, :normal, state}
  end

  @impl true
  def handle_info({:basic_cancel_ok, _meta}, state) do
    {:noreply, state}
  end

  defp setup_exchanges_and_queues(channel) do
    with :ok <- AMQP.Exchange.declare(channel, @exchange, :topic, durable: true),
         {:ok, _info} <- AMQP.Queue.declare(channel, @queue, durable: true),
         :ok <- AMQP.Queue.bind(channel, @queue, @exchange, routing_key: "*.events"),
         :ok <- AMQP.Queue.bind(channel, @queue, @exchange, routing_key: "*.requests"),
         :ok <- AMQP.Queue.bind(channel, @queue, @exchange, routing_key: "*.responses") do
      :ok
    end
  end

  defp handle_message(payload, meta) do
    case Jason.decode(payload) do
      {:ok, message} ->
        process_message(message, meta.routing_key)
        ack_message(meta)

      {:error, reason} ->
        Logger.error("Error decodificando mensaje: #{inspect(reason)}")
        nack_message(meta)
    end
  end

  defp process_message(message, routing_key) do
    Logger.info("Procesando mensaje de #{routing_key}: #{inspect(message)}")

    case routing_key do
      # EVENTOS
      "ventas.events" ->
        process_venta_event(message)

      "compras.events" ->
        process_compra_event(message)

      "pagos.events" ->
        process_pago_event(message)

      "envios.events" ->
        process_envio_event(message)

      "infracciones.events" ->
        process_infraccion_event(message)

      # SOLICITUDES (requests)
      "ventas.requests" ->
        process_venta_request(message)

      "pagos.requests" ->
        process_pago_request(message)

      "envios.requests" ->
        process_envio_request(message)

      "infracciones.requests" ->
        process_infraccion_request(message)

      # RESPUESTAS
      "ventas.responses" ->
        process_venta_response(message)

      "pagos.responses" ->
        process_pago_response(message)

      "envios.responses" ->
        process_envio_response(message)

      "infracciones.responses" ->
        process_infraccion_response(message)

      _ ->
        Logger.warning("Routing key no reconocido: #{routing_key}")
        :ok
    end
  end

  # ========================================
  # PROCESAMIENTO DE REQUESTS (Solicitudes)
  # ========================================

  defp process_venta_request(%{
         "request_type" => "verificar_stock",
         "compra_id" => compra_id,
         "producto_id" => producto_id
       }) do
    try do
      case GenServer.call(
             {:global, Libremarket.Ventas.Server},
             {:verificar_producto, producto_id}
           ) do
        {:ok, producto} ->
          GenServer.cast(
            {:global, Libremarket.Compras.Server},
            {:stock_verificado, compra_id, producto}
          )

        {:error, reason} ->
          GenServer.cast({:global, Libremarket.Compras.Server}, {:error_stock, compra_id, reason})
      end
    rescue
      e -> Logger.error("Error verificando stock: #{inspect(e)}")
    end
  end

  defp process_venta_request(%{
         "request_type" => "confirmar_venta",
         "compra_id" => compra_id,
         "producto_id" => producto_id
       }) do
    try do
      case GenServer.call({:global, Libremarket.Ventas.Server}, {:confirmar_venta, producto_id}) do
        {:ok, producto} ->
          GenServer.cast(
            {:global, Libremarket.Compras.Server},
            {:venta_confirmada, compra_id, producto}
          )

        {:error, reason} ->
          GenServer.cast({:global, Libremarket.Compras.Server}, {:error_stock, compra_id, reason})
      end
    rescue
      e -> Logger.error("Error confirmando venta: #{inspect(e)}")
    end
  end

  defp process_venta_request(%{"request_type" => "reponer_stock", "producto_id" => producto_id}) do
    try do
      GenServer.cast({:global, Libremarket.Ventas.Server}, {:reponer_stock, producto_id})
    rescue
      e -> Logger.error("Error reponiendo stock: #{inspect(e)}")
    end
  end

  defp process_venta_request(_), do: :ok

  defp process_pago_request(%{
         "request_type" => "procesar_pago",
         "compra_id" => compra_id,
         "pago_id" => pago_id
       }) do
    try do
      resultado = GenServer.call({:global, Libremarket.Pagos.Server}, {:procesarPago, pago_id})

      GenServer.cast(
        {:global, Libremarket.Compras.Server},
        {:pago_procesado, compra_id, resultado}
      )
    rescue
      e ->
        Logger.error("Error procesando pago: #{inspect(e)}")
        GenServer.cast({:global, Libremarket.Compras.Server}, {:pago_procesado, compra_id, false})
    end
  end

  defp process_pago_request(_), do: :ok

  defp process_envio_request(%{
         "request_type" => "procesar_envio",
         "compra_id" => compra_id,
         "producto_id" => producto_id,
         "forma_entrega" => forma_entrega
       }) do
    try do
      forma_atom = String.to_existing_atom(forma_entrega)

      envio =
        GenServer.call(
          {:global, Libremarket.Envios.Server},
          {:procesarEnvio, producto_id, forma_atom}
        )

      GenServer.cast({:global, Libremarket.Compras.Server}, {:envio_procesado, compra_id, envio})
    rescue
      e ->
        Logger.error("Error procesando envío: #{inspect(e)}")
        GenServer.cast({:global, Libremarket.Compras.Server}, {:envio_procesado, compra_id, nil})
    end
  end

  defp process_envio_request(_), do: :ok

  defp process_infraccion_request(%{
         "request_type" => "detectar_infracciones",
         "compra_id" => compra_id,
         "producto_id" => producto_id
       }) do
    try do
      tiene_infraccion =
        GenServer.call(
          {:global, Libremarket.Infracciones.Server},
          {:detectar_infracciones, producto_id}
        )

      GenServer.cast(
        {:global, Libremarket.Compras.Server},
        {:infracciones_detectadas, compra_id, tiene_infraccion}
      )

      if tiene_infraccion do
        alias Libremarket.AMQP.Publisher

        Publisher.publish("infracciones.events", %{
          "event_type" => "infraccion_detectada",
          "compra_id" => compra_id,
          "producto_id" => producto_id,
          "timestamp" => DateTime.utc_now() |> DateTime.to_iso8601()
        })
      end
    rescue
      e ->
        Logger.error("Error detectando infracciones: #{inspect(e)}")

        GenServer.cast(
          {:global, Libremarket.Compras.Server},
          {:infracciones_detectadas, compra_id, false}
        )
    end
  end

  defp process_infraccion_request(_), do: :ok

  # ========================================
  # PROCESAMIENTO DE EVENTS (Eventos)
  # ========================================

  defp process_venta_event(
         %{"event_type" => "producto_vendido", "producto_id" => producto_id} = _event
       ) do
    Logger.info("Producto vendido: #{producto_id}")
    :ok
  end

  defp process_venta_event(
         %{"event_type" => "stock_actualizado", "producto_id" => producto_id, "stock" => stock} =
           _event
       ) do
    Logger.info("Stock actualizado para producto #{producto_id}: #{stock} unidades")

    if stock < 3 do
      Logger.warning("¡Alerta! Stock bajo para producto #{producto_id}: #{stock} unidades")
    end

    :ok
  end

  defp process_venta_event(event) do
    Logger.warning("Evento de venta no reconocido: #{inspect(event)}")
    :ok
  end

  defp process_compra_event(%{"event_type" => "compra_realizada", "compra" => compra} = _event) do
    Logger.info("Compra realizada: #{inspect(compra)}")
    :ok
  end

  defp process_compra_event(
         %{"event_type" => "compra_fallida", "motivo" => motivo, "producto_id" => producto_id} =
           _event
       ) do
    Logger.warning("Compra fallida para producto #{producto_id}: #{motivo}")
    :ok
  end

  defp process_compra_event(event) do
    Logger.warning("Evento de compra no reconocido: #{inspect(event)}")
    :ok
  end

  defp process_pago_event(
         %{"event_type" => "pago_procesado", "pago_id" => pago_id, "resultado" => resultado} =
           _event
       ) do
    Logger.info("Pago #{pago_id} procesado: #{resultado}")
    :ok
  end

  defp process_pago_event(
         %{"event_type" => "pago_rechazado", "pago_id" => pago_id, "producto_id" => producto_id} =
           _event
       ) do
    Logger.warning("Pago rechazado: #{pago_id} para producto #{producto_id}")
    :ok
  end

  defp process_pago_event(event) do
    Logger.warning("Evento de pago no reconocido: #{inspect(event)}")
    :ok
  end

  defp process_envio_event(%{"event_type" => "envio_creado", "envio" => envio} = _event) do
    Logger.info("Envío creado: #{inspect(envio)}")
    :ok
  end

  defp process_envio_event(%{"event_type" => "envio_despachado", "envio_id" => envio_id} = _event) do
    Logger.info("Envío despachado: #{envio_id}")
    :ok
  end

  defp process_envio_event(event) do
    Logger.warning("Evento de envío no reconocido: #{inspect(event)}")
    :ok
  end

  defp process_infraccion_event(
         %{
           "event_type" => "infraccion_detectada",
           "compra_id" => compra_id,
           "producto_id" => producto_id
         } = _event
       ) do
    Logger.warning("Infracción detectada en compra: #{compra_id}, producto: #{producto_id}")
    :ok
  end

  defp process_infraccion_event(event) do
    Logger.warning("Evento de infracción no reconocido: #{inspect(event)}")
    :ok
  end

  defp process_venta_response(_), do: :ok
  defp process_pago_response(_), do: :ok
  defp process_envio_response(_), do: :ok
  defp process_infraccion_response(_), do: :ok

  defp ack_message(meta) do
    with {:ok, channel} <- Connection.get_channel() do
      AMQP.Basic.ack(channel, meta.delivery_tag)
    end
  end

  defp nack_message(meta) do
    with {:ok, channel} <- Connection.get_channel() do
      AMQP.Basic.nack(channel, meta.delivery_tag, requeue: false)
    end
  end
end
